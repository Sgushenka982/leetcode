/*Учитывая массив целых чисел, nums отсортированных в неубывающем порядке, удалите некоторые дубликаты на месте таким образом, чтобы каждый уникальный элемент появлялся не более двух раз. Относительный порядок элементов должен быть одинаковым.

        Поскольку в некоторых языках невозможно изменить длину массива, вместо этого вы должны поместить результат в первую часть массива nums. Более формально, если после удаления дубликатов остаются k элементы, то первые k элементы nums должны содержать конечный результат. Не имеет значения, что вы оставляете за пределами первых k элементов.

        Верните k после размещения конечного результата в первые k ячейки nums.

        Не выделяйте дополнительное пространство для другого массива. Вы должны сделать это, изменив входной массив на месте, добавив O (1) дополнительной памяти.

        Пользовательская оценка:

        Судья протестирует ваше решение с помощью следующего кода:

        int[] nums = [...]; // Входной массив
        int[] expectedNums = [...]; // Ожидаемый ответ правильной длины

        int k = Удаленные дубликаты (числа); // Вызывает вашу реализацию

        утверждение k == ожидаемые числа.длина;
        for (int i = 0; i < k; i++) {
        утвердить числа [i] == Ожидаемые числа[i];
        }
        Если все утверждения подтвердятся, то ваше решение будет принято.



        Пример 1:

        Входные данные: nums = [1,1,1,2,2,3]
        Вывод: 5, nums = [1,1,2,2,3,_]
        Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums равны 1, 1, 2, 2 и 3 соответственно.
        Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).
        Пример 2:

        Входные данные: nums = [0,0,1,1,1,1,2,3,3]
        Вывод: 7, nums = [0,0,1,1,2,3,3,_,_]
        Объяснение: Ваша функция должна возвращать k = 7, причем первые семь элементов nums равны 0, 0, 1, 1, 2, 3 и 3 соответственно.
        Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).


        Ограничения:

        1 <= nums.length <= 3 * 104
        -104 <= nums[i] <= 104
        nums сортируется в неубывающем порядке.*/

package tasks;

import java.util.Map;

public class RemoveDuplicatesFromSortedArrayII__80 implements Task{
    @Override
    public String execute(Map params) {
        return String.valueOf(removeDuplicates((int[]) params.get("value")));
    }

    public int removeDuplicates(int[] nums) {
        int index = 0;

        for (int i = 0; i<nums.length;i++) {
            if (i < 2)
                index++;
            else if(nums[i] != nums[index-1] || nums[i] != nums[index-2]){
                nums[index]=nums[i];
                index++;
            }
        }

        for (int i = index; i<nums.length;i++){
            nums[i] = 0;
        }

        return index;
    }
}
