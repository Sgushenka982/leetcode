/*Учитывая целочисленный массив nums и целое число val, удалите все вхождения val in nums на месте. Порядок элементов может быть изменен. Затем верните количество элементов вnums которые не равны val.
Учтите количество элементов, в nums которых не равно val be k, чтобы быть принятым, вам нужно выполнить следующие действия:
Измените массив nums таким образом, чтобы первые k элементы nums содержали элементы, которые не равны val. Остальные элементы nums не важны так же, как и размер nums.
        Возврат k.


        Пользовательский судья:

        Судья протестирует ваше решение с помощью следующего кода:

        int[] nums = [...]; // Входной массив
        int val = ...; // Значение для удаления
        int[] expectedNums = [...]; // Ожидаемый ответ правильной длины.
        // Он отсортирован без значений, равных val.

        int k = removeElement(nums, val); // Вызывает вашу реализацию

        утвердить k == ожидаемые значения.длина;
        сортировать (nums, 0, k); // Отсортировать первые k элементов nums
        for (int i = 0; i < Фактическая длина; i++) {
        утверждать числа[i] == Ожидаемые числа[i];
        }
        Если все утверждения пройдут, то ваше решение будет принято.



        Пример 1:

        Ввод: числа = [3,2,2,3], значение = 3
        Вывод: 2, числа = [2,2,_,_]
        Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 2.
        Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).
        Пример 2:

        Ввод: числа = [0,1,2,2,3,0,4,2], значение = 2
        Вывод: 5, числа = [0,1,4,0,3,_,_,_]
        Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums содержат 0, 0, 1, 3 и 4.
        Обратите внимание, что пять элементов могут быть возвращены в любом порядке.
        Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).


        Ограничения:

        0 <= nums.length <= 100
        0 <= nums[i] <= 50
        0 <= val <= 100*/

package tasks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

public class RemoveElement__27 implements Task{
    @Override
    public String execute(Map params) {
        return String.valueOf(removeElement((int[]) params.get("value1"),(Integer) params.get("value2")));
    }

    public int removeElement(int[] nums, int val) {
//        int index = 0;
//
//        for(int i = 0; i< nums.length;i++){
//            if(nums[i]!=val){
//                nums[index] = nums[i];
//                index++;
//            }
//        }
//        return index;

        // в литкоде не пашет
        nums = Arrays.stream(nums).filter(num -> num != val).toArray();
        return nums.length;
    }
}
